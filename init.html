<!DOCTYPE html>
<html>
<head>
    <title>11 Reasons not to roll your own init, uninit and reinit functions</title>
		<link type="text/css" rel="stylesheet" href="style.css"/>
</head>
<body>
<a href="index.html">Index</a>
    <h1 id="reasons-not-to-roll-your-own-init-uninit-and-reinit-functions">11 Reasons not to roll your own init, uninit and reinit functions</h1>
<ul>
<li><a href="#10"># 10 : Write less code</a></li>
<li><a href="#9"># 9 : Less Assembly / Smaller Binaries</a></li>
<li><a href="#8"># 8 : Performance - (single vs. double assignment)</a></li>
<li><a href="#7"># 7 : Ensure no leaks (destructor)</a></li>
<li><a href="#6"># 6 : Help the compiler help you (warnings)</a></li>
<li><a href="#5"># 5 : Smaller VTables</a></li>
<li><a href="#4"># 4 : can copy, swap or move without worry about the 'current' state</a></li>
<li><a href="#3"># 3 : Save some trips to Undefined-Behavior-Land</a></li>
<li><a href="#2"># 2 : No need to lock (constructor can't be run in multiple threads)</a></li>
<li><a href="#1"># 1 : Can't initialize references and const members in init(..)</a></li>
<li><a href="#0"># 0 : Because the standard said so (consistency)</a></li>
</ul>
<h2 id="write-less-code"># <a name="10"></a> 10 : Write less code</h2>
<p>It has been statistically proven that writing less code is not only good for the health of the person writing
the code (by saving you some valuable typing time) but also all your reviewers and the future people who will
come to scrutinize your code.</p>
<pre><code>class RAIIClass
{
public:
    RAIIClass(int counter, std::string component_name)
    : m_counter{counter}, m_component_name{std::move(component_name)} {}

    ~RAIIClass()
    {
        // some work
    }
private:
    int m_counter{};
    std::string m_component_name;
};

// later
RAIIClass object;
use(object);
</code></pre>
<pre><code>class NotRAIIClass
{
public:
    RAIIClass() = default;
    void init(counter c, std:string comp_name)
    {
        m_counter = c;
        m_component_name = std::move(comp_name);
    }

    void uninit()
    {
        // some work
    }
private:
    int m_counter{};
    std::string m_component_name;
};

// later
RAIIClass object;
object.init(1, &quot;foo&quot;);
use(object);
object.uninit();
</code></pre>
<p># of lines in RAIIClass : 17<br />
# of characters in RAIIClass : 309<br />
# of lines in NotRAIIClass : 23<br />
# of characters in NotRAIIClass : 386</p>
<p><em>Do the right thing. Save your team members some headache and write less code today!</em></p>
<h2 id="less-assembly-smaller-binaries"># <a name="9"></a> 9 : Less Assembly / Smaller Binaries</h2>
<p>Here's the assembly generated by that same RAII class in Visual Studio v19.14 :-</p>
<ul>
<li>O1 (Minimize Size): 995</li>
<li>O2 (Maximize Speed): 1020</li>
</ul>
<p>And the Not-RAII class:</p>
<ul>
<li>O1 (Minimize Size): 1061 (+66 lines)</li>
<li>O2 (Maximize Speed): 1080 (+60 lines)</li>
</ul>
<p>That's not a huge difference to make a compelling enough argument by itself,
but its <em>a</em> reason all the same, considering you're going to multiply that
difference across every class in your program.</p>
<h2 id="performance-single-vs.double-assignment"># <a name="8"></a> 8 : Performance - (single vs. double assignment)</h2>
<p>In the Not-RAII case, each member in your class gets assigned twice:</p>
<pre><code>    NotRAIIClass c; // once here
    c.init(1, &quot;pasnf&quot;); // again here
</code></pre>
<p>Wheras in the RAIIClass, initialization happens exactly once:</p>
<pre><code>    RAIIClass c{1, &quot;pasnf&quot;};
</code></pre>
<p>This can make a bigger difference when you have 7-8 members in
your class, plus if any of those members use init(..) functions too:</p>
<pre><code>NotRAII::NotRAII() = default;

NotRAII::init(string name, string verb, array&lt;string&gt; values, string sub_class_arg)
{
    m_name = name;
    m_verb = verb;
    values = m_values;
    m_sub_class-&gt;init(sub_class_arg);
}
</code></pre>
<h2 id="ensure-no-leaks-destructor"># <a name="7"></a> 7 : Ensure no leaks (destructor)</h2>
<p>Unless you call <code>uninit</code> in your destructor, there is nothing to ensure the person using your
class will remember to call <code>uninit()</code> to clean up your resources.</p>
<p>Furthermore <code>uninit</code> will not get called in case an exception is thrown while you're object
is alive, resulting in a sure-fire resource leak.</p>
<h2 id="help-the-compiler-help-you-warnings"># <a name="6"></a> 6 : Help the compiler help you (warnings)</h2>
<p>Uninitialized variables remain one of the biggest source of bugs today in old-style code.
Most compilers and static analysis tools can easily identify any members you forgot
to initialize in your constructor. This CANNOT be done with init(..) functions, as
the compiler is unable to recognize this as any special function.</p>
<p>Furthermore, tools like Resharper can also identify if any members have been assigned in the
incorrect order, which can be another source of really subtle bugs.</p>
<h2 id="smaller-vtables"># <a name="5"></a> 5 : Smaller VTables</h2>
<p>Typically <code>init()</code> and <code>uninit()</code> functions get implemented as virtual methods to allow initializing them
in a context where they may be accessible through a base pointer/reference. This is in addition
to the destructor, which also needs to be virtual, just in case anybody inheriting your class
decides to add cleanup logic in their destructor.</p>
<pre><code>auto const p = std::make_shared&lt;NotRAIIDerived&gt;();
use(*p);

auto use(NotRAIIBase&amp; b)
{
  b.init(&quot;asp&quot;, a); // since b is a 'base' pointer, init has to be virtual
};
</code></pre>
<p>This would still be simple enough, except for the cases where you have to worry about multiple ways to
initialize your class:</p>
<pre><code>class IMyInterface
{
    virtual void init();
    virtual void init(std::string a, int b);
    virtual void uninit();
    virtual ~IMyInterface();
}

class IExtendedInterface : public IMyInterface
{
    virtal void init(std::string a, int b, std::vector&lt;int&gt; c); // oops, need to add this init now
}
</code></pre>
<p>Having to support multiple virtual init functions in this manner for extension of your interface typically results
in massive VTables in order to support every combination of parameters that can be used to initialize your class.</p>
<p>This is avoided entirely in RAII, since initialization is done in the constructor, there is no need to make
it virtual. Dynamic dispatch is wholly unnecesssary because the person creating the object has the
full type information available at the time of construction.</p>
<pre><code>auto const p = std::make_shared&lt;RAIIDerived&gt;(..);
use(*p);
auto use(RAIIBase&amp; b)
{
 // already initialized
}
</code></pre>
<h2 id="can-copy-swap-or-move-without-worry-about-the-current-state"># <a name="4"></a> 4 : can copy, swap or move without worry about the 'current' state</h2>
<p>Let's say that you've gotten a hold of an object in your function and you'd like
to make a copy of it:</p>
<pre><code>auto func(my_class const&amp; object)
{
    auto temp = my_class{object};
    temp.init( ?? );
}
</code></pre>
<p>If you are using <code>init</code> semantics - you simply
do not know if you need to call init after the copy or not (or what parameters to call it with).
Some <code>init</code> functions may do special work aside from just assigning state. With RAII,
you could assume that the copy-constructor would do that same work by delegating constructors.
With <code>init</code> semantics, the copy-constructor may not do anything at all. You may have to call <code>init</code>
to actually initailize the object, in which case there's no way of knowing what parameters you
would need to pass to it to match the original object.</p>
<h2 id="save-some-trips-to-undefined-behavior-land"># <a name="3"></a> 3 : Save some trips to Undefined-Behavior-Land</h2>
<p>Now we come to probably <strong>the most important reason</strong> to use RAII over <code>init</code> semantics. Undefined
behavior is the bane of every developer's existence and a nightmare to debug because of the unpredicatability
of the bugs that result from them.</p>
<p>Using <code>init</code> semantics opens up the avenue for a whole sleuth of undefined-behavior bugs (depending on a developer
interprets such a class is intended to be used).
Since there is no <strong>one</strong> set of guidelines for <code>init</code> semantics, everyone implements it in a different way,
which means that the guarantees provided by the class are entirely dependant on the library writer.</p>
<ul>
<li>use before init</li>
</ul>
<pre><code>NotRAIIClass c;
use(c);     // oops
c.init();
</code></pre>
<ul>
<li>double-init</li>
</ul>
<pre><code>NotRAIIClass c;
c.init();
// .. some time later ..
c.init();   // oops
</code></pre>
<ul>
<li>use after uninit</li>
</ul>
<pre><code>NotRAIIClass c;
c.uninit();
use(c);     // oops
</code></pre>
<ul>
<li>double uninit</li>
</ul>
<pre><code>NotRAIIClass c;
c.uninit();
c.uninit(); // oops
</code></pre>
<ul>
<li>init after uninit</li>
</ul>
<pre><code>NotRAIIClass c;
c.init();
c.unint();
c.init();   // oops
</code></pre>
<ul>
<li>uninit without init</li>
</ul>
<pre><code>NotRAIIClass c;
c.uninit(); // oops
</code></pre>
<p>What would happen in the above case?</p>
<ul>
<li>maybe a crash</li>
<li>maybe undefined behavior</li>
<li>maybe nothing at all (no way to know)</li>
</ul>
<p><strong>Note that it is perfectly possible for the library writer to define the class in such a way
that every one of the above scenarios is well-supported and does not result in undefined behavior.
But to do so is an incredible amount of redundant work, that can be entirely avoided by strictly using RAII</strong></p>
<p>RAII ensures that you are unable to access an object unless it is in an initialized <em>good</em> state.
Its as simple as that.</p>
<h2 id="no-need-to-lock-constructor-cant-be-run-in-multiple-threads"># <a name="2"></a> 2 : No need to lock (constructor can't be run in multiple threads)</h2>
<p>With init-semantics, since the init function is responsible for assigning data to the object's members,
if there is any possibility of the object being used in a multi-threaded context,
it must be run under lock to ensure thread-safety. This goes the same for uninit functions:</p>
<pre><code>auto c = make_shared&lt;NotRAIIClass&gt;();
thread_A.share(c);
thread_B.share(c);

// A calls c.init()
// B calls c.init()
// some time later
// A calls c.uninit()
// B calls c.uninit()
NotRAIIClass::init()
{
  std::scoped_lock lock{m_mutex};
  // assign state
}
NotRAIIClass::uninit()
{
  std::scoped_lock lock{m_mutex};
  // assign state
}
</code></pre>
<p>On the other hand, with RAII, the constructor is the first point in code where an object is accessed.
That means it is quite simply impossible for a constructor to be re-entrant:</p>
<pre><code>auto c = make_shared&lt;RAIIClass&gt;(..); // no way for more than way thread
thread_A.share(c);
thread_A.share(c);
</code></pre>
<h2 id="cant-initialize-references-and-const-members-in-init"># <a name="1"></a> 1 : Can't initialize references and const members in init(..)</h2>
<p>References and const members must be initialized in the constructor as they cannot be re-assigned.
This means that if you want to support either references or const members, you cannot use <code>init-semantics</code>:</p>
<pre><code>class RAIIClass
{
public:
    RAIIClass(counter_ref, max_count)
    : m_counter_ref{counter_ref}
    , m_max_count{max_count}  // &lt;-- can't assign these in init()
    {}

private:
    int&amp;        m_counter_ref;
    int const   m_max_count;
};
</code></pre>
<h2 id="because-the-standard-said-so-consistency"># <a name="0"></a> 0 : Because the standard said so (consistency)</h2>
<p>See: <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-raii">http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-raii</a><br />
'Nuff said.</p>


</body>
</html>
